#include "Adc.h"

#define SAMP_COUNT 6

u16 g_usAdcValue;
/*
*********************************************************************************************************
*	函 数 名: 
*	功能说明: 初始化ADC
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/

void bsp_InitAdc(void)
{
  /*  配置GPIO模式， PC4为浮空输入，无中断。用于 ADC模拟输入 AIN2 */
  GPIO_Init(GPIOD, GPIO_PIN_3, GPIO_MODE_IN_FL_NO_IT);
  
  /* 恢复缺省配置 */
  ADC1_DeInit();
  
  /* 配置 ADC1 设备 */
  ADC1_Init(
            /* 第1个形参表示转换模式
            ADC1_CONVERSIONMODE_SINGLE     表示连续转换
            ADC2_CONVERSIONMODE_CONTINUOUS 表示连选转换
            */
            ADC1_CONVERSIONMODE_SINGLE,
            
            /* 第2个形参表示转换的ADC通道, 本例是 AIN2 */
            ADC1_CHANNEL_4,
            
            /* 第3个形参表示预分频 */
            ADC1_PRESSEL_FCPU_D2,
            
            /* 第4个形参表示外部触发源，TIM 或者 外部GPIO */
            ADC1_EXTTRIG_TIM,
            
            /* 第5个形参表示是否使能外部触发模式 */
            DISABLE,
            
            /* 第6个形参表示ADC采集结果的数据对齐格式, 左对齐或右对齐 */
            ADC1_ALIGN_RIGHT,
            
            /* 第7个形参表示施密特触发通道 */
            ADC1_SCHMITTTRIG_CHANNEL9,
            
            /* 第8个参数表示是否使能施密特触发通道 */
            DISABLE
              );
  
  ADC1_StartConversion();		/* 软件启动下次ADC转换 */
}
/*
*********************************************************************************************************
*	函 数 名: AdcPro
*	功能说明: ADC采样处理，插入1ms systick中断进行调用
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void bsp_AdcPro(void)
{
  static uint16_t buf[SAMP_COUNT];
  static uint8_t write;
  uint16_t sum;
  uint8_t i;
  
  buf[write] = ADC1_GetConversionValue();
  if (++write >= SAMP_COUNT)
  {
    write = 0;
  }
  
  /* 下面这段代码采用求平均值的方法进行滤波
  也可以改善下，选择去掉最大和最下2个值，使数据更加精确
  */
  sum = 0;
  for (i = 0; i < SAMP_COUNT; i++)
  {
    sum += buf[i];
  }
  g_usAdcValue = sum / SAMP_COUNT;	/* ADC采样值由若干次采样值平均 */
  
  ADC1_StartConversion();		/* 软件启动下次ADC转换 */
}

/*
*********************************************************************************************************
*	函 数 名: GetADC
*	功能说明: 读取ADC采样的平均值
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
uint16_t GetADC(void)
{
  uint16_t ret;
  
  /* 因为	g_AdcValue 变量在systick中断中改写，为了避免主程序读变量时被中断程序打乱导致数据错误，因此需要
  关闭中断进行保护 */
  
  /* 进行临界区保护，关闭中断 */
//  disableInterrupts();	/* 禁止中断。这个宏在 stm8s.h 中定义 */
  
  ret = g_usAdcValue;
  
//  enableInterrupts(); 	/* 使能中断。这个宏在 stm8s.h 中定义 */
  
  return ret;
}



//40~100    阻值变化K
//5.810,4.897,4.415,3.525,3.011,2.582,2.223,1.921,1.667,1.451,1.268,1.112,0.977
//u8 OM[]={58,48,44,35,30,25,22,19,16,14,12,11,9};
//u8 OM[]={65,52,43,36,29,24,20,17,14,12,10,9,8};//10K  3950

//100K  3950
//52.93,  43.34,  35.70,  29.56,  24.60,  20.58,  17.29,  14.58,  12.35,  10.49,  8.927,  7.630,  6.550
//u16 OM[] = {529,433,357,295,246,205,172,145,123,105,89,76,65};//10*

//根据热敏电阻阻值，计算对应温度


//10K  3990
//52.589， 43.018， 35.394， 29.280， 24.344， 20.335， 17.061， 14.373， 12.156，10.318， 8.7885，7.5101， 6.4376
//40~100
u16 OM[] = {529,430,354,293,243,203,171,144,121,103,88,75,64};//扩大10倍

u16 Get_Temp()
{
  u8 Temp;
  u32 Res;
  u16 AD;
  u8 i;//,Temp;
  AD = GetADC();
  Res = 1000UL*AD/(1024 - AD);//百 OM
  
  for(i=0;i<sizeof(OM)/sizeof(OM[0]);i++)
 //for(i=0;i<14;i++)
 { 
   Temp= 35 +i*5;
  if( Res<OM[i])
  {
    continue;
  }
  else break;
 }
return Temp;
}


